#!/usr/bin/env perl

#
# InspIRCd -- Internet Relay Chat Daemon
#
#   Copyright (C) 2013 InspIRCd.org
#   Copyright (C) 2009-2010 Daniel De Graaf <danieldg@inspircd.org>
#   Copyright (C) 2007, 2009 Dennis Friis <peavey@inspircd.org>
#   Copyright (C) 2003, 2006-2008 Craig Edwards <craigedwards@brainbox.cc>
#   Copyright (C) 2006-2008 Robin Burchell <robin+git@viroteck.net>
#   Copyright (C) 2008 Thomas Stagner <aquanight@inspircd.org>
#   Copyright (C) 2007 John Brooks <john.brooks@dereferenced.net>
#   Copyright (C) 2006 Oliver Lupton <oliverlupton@gmail.com>
#   Copyright (C) 2003-2006 Craig McLure <craig@chatspike.net>
#
# This file is part of InspIRCd.  InspIRCd is free software: you can
# redistribute it and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, version 2.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#


BEGIN {
	require 5.8.0;
}

use strict;
use warnings FATAL => qw(all);

use Data::Dumper;
BEGIN {
	$Data::Dumper::Sortkeys = 1;
	$Data::Dumper::Useqq = 1;
};

use File::Copy ();
use Socket;
use Cwd;
use Getopt::Long;

# Utility functions for our buildsystem
use make::utilities;
use make::configure;
use make::gnutlscert;
use make::opensslcert;

###############################################################################################
#
#                                 NON-EDITABLE VARIABLES
#
###############################################################################################

our ($opt_use_gnutls, $opt_rebuild, $opt_use_openssl, $opt_nointeractive, $opt_ports,
    $opt_epoll, $opt_kqueue, $opt_noports, $opt_noepoll, $opt_nokqueue,
    $opt_noipv6, $opt_maxbuf, $opt_disable_debug, $opt_freebsd_port,
	$opt_system, $opt_uid);

our ($opt_cc, $opt_base_dir, $opt_config_dir, $opt_module_dir, $opt_binary_dir, $opt_data_dir, $opt_log_dir);

sub list_extras ();

sub enable_extras (@);

sub disable_extras (@);

my @opt_enableextras;
my @opt_disableextras;

GetOptions (
	'enable-gnutls' => \$opt_use_gnutls,
	'rebuild' => \$opt_rebuild,
	'system' => \$opt_system,
	'uid=s' => \$opt_uid,
	'enable-openssl' => \$opt_use_openssl,
	'disable-interactive' => \$opt_nointeractive,
	'enable-ports' => \$opt_ports,
	'enable-epoll' => \$opt_epoll,
	'enable-kqueue' => \$opt_kqueue,
	'disable-ports' => \$opt_noports,
	'disable-epoll' => \$opt_noepoll,
	'disable-kqueue' => \$opt_nokqueue,
	'disable-ipv6' => \$opt_noipv6,
	'with-cc=s' => \$opt_cc,
	'with-maxbuf=i' => \$opt_maxbuf,
	'enable-freebsd-ports-openssl' => \$opt_freebsd_port,
	'prefix=s' => \$opt_base_dir,
	'config-dir=s' => \$opt_config_dir,
	'module-dir=s' => \$opt_module_dir,
	'binary-dir=s' => \$opt_binary_dir,
	'data-dir=s' => \$opt_data_dir,
	'log-dir=s' => \$opt_log_dir,
	'disable-debuginfo' => sub { $opt_disable_debug = 1 },
	'help'	=> sub { showhelp(); },
	'update' => sub { update(); },
	'clean' => sub { clean(); },
	'list-extras' => sub { list_extras; exit 0; }, # This, --enable-extras, & --disable-extras are for non-interactive managing
	'enable-extras=s@' => \@opt_enableextras, #     " "
	'disable-extras=s@' => \@opt_disableextras, #    " "
	'generate-openssl-cert' => sub { make_openssl_cert(); exit(0); },
	'generate-gnutls-cert' => sub { make_gnutls_cert(); exit(0); }
);

if (scalar(@opt_enableextras) + scalar(@opt_disableextras) > 0) {
	@opt_enableextras = split /,/, join(',', @opt_enableextras);
	@opt_disableextras = split /,/, join(',', @opt_disableextras);
	enable_extras(@opt_enableextras);
	disable_extras(@opt_disableextras);
	list_extras;
	print "Remember: YOU are responsible for making sure any required libraries have been installed!\n";
	exit 0;
}

our $interactive = !(
	(defined $opt_base_dir) ||
	(defined $opt_config_dir) ||
	(defined $opt_module_dir) ||
	(defined $opt_base_dir) ||
	(defined $opt_binary_dir) ||
	(defined $opt_data_dir) ||
	(defined $opt_log_dir) ||
	(defined $opt_nointeractive) ||
	(defined $opt_cc) ||
	(defined $opt_noipv6) ||
	(defined $opt_kqueue) ||
	(defined $opt_epoll) ||
	(defined $opt_ports) ||
	(defined $opt_use_openssl) ||
	(defined $opt_nokqueue) ||
	(defined $opt_noepoll) ||
	(defined $opt_noports) ||
	(defined $opt_maxbuf) ||
	(defined $opt_system) ||
	(defined $opt_uid) ||
	(defined $opt_use_gnutls) ||
	(defined $opt_freebsd_port)
);

chomp(our $topdir = getcwd());
our $this = resolve_directory($topdir);							# PWD, regardless...
our @modlist = ();							  		# Declare for Module list...
our %config = ();						   			# Initiate configuration hash...
our $cache_loaded = getcache();
$config{ME} = resolve_directory($topdir);						# Present working directory

$config{BASE_DIR} = $config{ME}."/run";

if (defined $opt_base_dir) {
	$config{BASE_DIR} = $opt_base_dir;
} elsif (defined $opt_system) {
	$config{BASE_DIR} = '/var/lib/inspircd';
}

if (defined $opt_system) {
	$config{UID} = $opt_uid || 'ircd';
	$config{CONFIG_DIR}	 = '/etc/inspircd';
	$config{MODULE_DIR}	 = '/usr/lib/inspircd';
	$config{BINARY_DIR}	 = '/usr/sbin/';
	$config{BUILD_DIR}	 = resolve_directory($config{ME}."/build");		# Build directory
	$config{DATA_DIR}	 = '/var/inspircd';
	$config{LOG_DIR}	 = '/var/log/inspircd';
} else {
	$config{UID} = $opt_uid || $<;
	$config{CONFIG_DIR}	 = resolve_directory($config{BASE_DIR}."/conf");	# Configuration directory
	$config{MODULE_DIR}	 = resolve_directory($config{BASE_DIR}."/modules");	# Modules directory
	$config{BINARY_DIR}	 = resolve_directory($config{BASE_DIR}."/bin");		# Binary directory
	$config{BUILD_DIR}	 = resolve_directory($config{ME}."/build");         	# Build directory
	$config{DATA_DIR}	 = resolve_directory($config{BASE_DIR}."/data");	# Data directory
	$config{LOG_DIR}	 = resolve_directory($config{BASE_DIR}."/logs");	# Log directory
}

if (defined $opt_config_dir) {
	$config{CONFIG_DIR} = $opt_config_dir;
}
if (defined $opt_module_dir) {
	$config{MODULE_DIR} = $opt_module_dir;
}
if (defined $opt_binary_dir) {
	$config{BINARY_DIR} = $opt_binary_dir;
}
if (defined $opt_data_dir) {
	$config{DATA_DIR} = $opt_data_dir;
}
if (defined $opt_log_dir) {
	$config{LOG_DIR} = $opt_log_dir;
}
chomp($config{HAS_GNUTLS}   = `pkg-config --modversion gnutls 2>/dev/null | cut -c 1,2,3`);	# GnuTLS version

if (defined $opt_freebsd_port)
{
	chomp($config{HAS_OPENSSL} = `pkg-config --modversion openssl 2>/dev/null`);
	chomp($config{HAS_OPENSSL_PORT}  = `pkg-config --modversion openssl 2>/dev/null`);
	$config{USE_FREEBSD_BASE_SSL} = "n";
}
else
{
	if ($^O eq "freebsd")
	{
		# Default: use base SSL
		chomp($config{HAS_OPENSSL} = `openssl version | cut -d ' ' -f 2`);			# OpenSSL version, FreeBSD-specific
		chomp($config{HAS_OPENSSL_PORT}  = `pkg-config --modversion openssl 2>/dev/null`);	# Port version, may differ
	}
	else
	{
		chomp($config{HAS_OPENSSL}  = `pkg-config --modversion openssl 2>/dev/null`);		# OpenSSL version, others
		$config{HAS_OPENSSL_PORT} = "";
	}
}

chomp(our $gnutls_ver = $config{HAS_GNUTLS});
chomp(our $openssl_ver = $config{HAS_OPENSSL});
$config{USE_GNUTLS}	    = "n";
if (defined $opt_use_gnutls)
{
	$config{USE_GNUTLS} = "y";					# use GnuTLS
}
$config{USE_OPENSSL}	= "n";						# use OpenSSL
if (defined $opt_use_openssl)
{
	$config{USE_OPENSSL} = "y";
}

if (!defined $opt_disable_debug) {
	$config{OPTIMISATI}	 = "-g1";			     	# optimisation flag
} else {
	$config{OPTIMISATI}	 = "-O2";
}

$config{HAS_STRLCPY}	= "false";			  		# check for strlcpy
$config{HAS_STDINT}	 = "false";					# check for stdint.h
$config{USE_KQUEUE}	 = "y";						# kqueue enabled
if (defined $opt_nokqueue) {
	$config{USE_KQUEUE} = "n";
}
$config{USE_POLL}     = "y";						# poll enabled
$config{USE_EPOLL}	  = "y";					# epoll enabled
if (defined $opt_noepoll)
{
	$config{USE_EPOLL} = "n";
}
$config{USE_PORTS}	  = "y";					# epoll enabled
if (defined $opt_noports)
{
	$config{USE_PORTS} = "n";
}
$config{_SOMAXCONN} = SOMAXCONN;					# maximum connections in accept queue
$config{OSNAME}       	    = $^O;			      		# operating system name
$config{IS_DARWIN}	  = "NO";					# Darwin OS?
$config{STARTSCRIPT}	  = "inspircd";					# initiate script?
$config{DESTINATION}	  = "BASE";					# Base path
if ($config{OSNAME} =~ /darwin/i)
{
	$config{IS_DARWIN} = "YES";
	$config{STARTSCRIPT}	  = "org.inspircd.plist";		# initiate script for Darwin OS X
	$config{CC} 		    = "xcrun clang++";			# C++ compiler for OS X
}
else
{
	$config{CC} 		    = "g++";				# C++ compiler
}
if (defined $opt_cc)
{
	$config{CC} = $opt_cc;
}
our $exec = $config{CC} . " -dumpversion | cut -c 1";
chomp($config{GCCVER}		= `$exec`);				# major GCC version
$exec = $config{CC} . " -dumpversion | cut -c 3";
chomp($config{GCCMINOR}		= `$exec`);
$config{MAXBUF}			= "512";				# maximum buffer size

if ($config{HAS_OPENSSL} =~ /^([-[:digit:].]+)(?:[a-z])?(?:\-[a-z][0-9])?/) {
	$config{HAS_OPENSSL} = $1;
} else {
	$config{HAS_OPENSSL} = "";
}

if (($config{GCCVER} eq "") || ($config{GCCMINOR} eq "")) {
	if ($config{IS_DARWIN} eq "YES") {
		print $config{CC} . " was not found! You require clang++ (the LLVM C++ compiler, part of the OS X developer tools) to build InspIRCd!\n";
	} else {
		print $config{CC} . " was not found! You require g++ (the GNU C++ compiler, part of GCC) to build InspIRCd!\n";		
	}
	exit;
}

# Get & set some important variables..
getmodules();

sub clean
{
	unlink(".config.cache");
}

our ($has_epoll, $has_ports, $has_kqueue) = (0, 0, 0);

sub update
{
	eval {
		chomp($topdir = getcwd());
		$this = resolve_directory($topdir);					     # PWD, regardless...
		getmodules();
		# Does the cache file exist?
		if (!getcache()) {
			# No, it does not exist :`( => *BASH*
			print "You have not executed ./configure as of yet. Please run ./configure before trying to run the update script.\n";
			exit 0;
		} else {
			# loaded cache file and all our variables..
			print "Updating files...\n";
			if (defined($opt_disable_debug) && $opt_disable_debug == 1)
			{
				print "Disabling debug information (-g).\n";
				$config{OPTIMISATI} = "";
			}
			$has_epoll = $config{HAS_EPOLL};
			$has_ports = $config{HAS_PORTS};
			$has_kqueue = $config{HAS_KQUEUE};
			writefiles(1);
			makecache();
			print "Complete.\n";
			exit;
		}
	};
	if ($@)
	{
		print "Configure update failed: $@\n";
	}
	exit;
}


sub test_compile {
	my $feature = shift;
	my $fail = 0;
	$fail ||= system "$config{CC} -o test_$feature make/check_$feature.cpp >/dev/null 2>&1";
	$fail ||= system "./test_$feature";
	unlink "test_$feature";
	return !$fail;
}

print "Running non-interactive configure...\n" unless $interactive;
print "Checking for previous configuration cache file... ";
print ($cache_loaded ? "found\n" : "not found\n");
$config{SYSTEM} = lc $^O;
print "Acquirng operating system version... $config{SYSTEM}\n";

$exec = $config{CC} . " -dumpversion | cut -c 1";
chomp($config{GCCVER}		= `$exec`);				# major GCC version
$exec = $config{CC} . " -dumpversion | cut -c 3";
chomp($config{GCCMINOR}		= `$exec`);

printf "Checking if stdint.h exists... ";
$config{HAS_STDINT} = "true";
our $fail = 0;
open(STDINT, "</usr/include/stdint.h") or $config{HAS_STDINT} = "false";
if ($config{HAS_STDINT} eq "true") {
	close(STDINT);
}
print "yes\n" if $config{HAS_STDINT} eq "true";
print "no\n" if $config{HAS_STDINT} eq "false";

printf "Checking if strlcpy exists... ";
# Perform the strlcpy() test..
$config{HAS_STRLCPY} = "false";
$fail = 0;
open(STRLCPY, "</usr/include/string.h") or $fail = 1;
if (!$fail) {
	while (defined(my $line = <STRLCPY>)) {
		chomp($line);
		# try and find the delcaration of:
		# size_t strlcpy(...)
		if ($line =~ /size_t(\0x9|\s)+strlcpy/)	{
			$config{HAS_STRLCPY} = "true";
		}
	}
	close(STRLCPY);
}
print "yes\n" if $config{HAS_STRLCPY} eq "true";
print "no\n" if $config{HAS_STRLCPY} eq "false";

printf "Checking if kqueue exists... ";
$has_kqueue = 0;
$fail = 0;
open(KQUEUE, "</usr/include/sys/event.h") or $fail = 1;
if (!$fail) {
	while (defined(my $line = <KQUEUE>)) {
		chomp($line);
		# try and find the delcaration of:
		# int kqueue(void);
		if ($line =~ /int(\0x9|\s)+kqueue/) {
			$has_kqueue = 1;
		}
	}
	close(KQUEUE);
}
print "yes\n" if $has_kqueue == 1;
print "no\n" if $has_kqueue == 0;

printf "Checking for epoll support... ";
$has_epoll = test_compile('epoll');
print $has_epoll ? "yes\n" : "no\n";

printf "Checking for eventfd support... ";
$config{HAS_EVENTFD} = test_compile('eventfd') ? 'true' : 'false';
print $config{HAS_EVENTFD} eq 'true' ? "yes\n" : "no\n";

printf "Examining if Solaris I/O completion ports are available... ";
$has_ports = 0;
our $system = `uname -s`;
chomp ($system);
$has_ports = 1 if ($system eq "SunOS");

if ($has_ports) {
	my $kernel = `uname -r`;
	chomp($kernel);
	if (($kernel !~ /^5\.1./)) {
		$has_ports = 0;
	}
}
print "yes\n" if $has_ports == 1;
print "no\n" if $has_ports == 0;

$config{HAS_EPOLL} = $has_epoll;
$config{HAS_KQUEUE} = $has_kqueue;

printf "Checking for libgnutls... ";
if (defined($config{HAS_GNUTLS}) && (($config{HAS_GNUTLS}) || ($config{HAS_GNUTLS} eq "y"))) {
	if (defined($gnutls_ver) && ($gnutls_ver ne "")) {
		print "yes\n";
		$config{HAS_GNUTLS} = "y";
	} else {
		print "no\n";
		$config{HAS_GNUTLS} = "n";
	}
} else {
	print "no\n";
	$config{HAS_GNUTLS} = "n";
}

printf "Checking for openssl... ";
if (defined($config{HAS_OPENSSL}) && (($config{HAS_OPENSSL}) || ($config{HAS_OPENSSL} eq "y"))) {
	if (defined($openssl_ver) && ($openssl_ver ne "")) {
		print "yes\n";
		$config{HAS_OPENSSL} = "y";
	} else {
		print "no\n";
		$config{HAS_OPENSSL} = "n";
	}
} else {
	print "no\n";
	$config{HAS_OPENSSL} = "n";
}

printf "Checking to see if you are running an ancient, unsupported O.S. ... ";
if ($config{OSNAME} =~ /FreeBSD/i)
{
	my $version = `uname -r`;
	if ($version =~ /^4\./)
	{
		print "yes.\n";
		print "FreeBSD 4.x is no longer supported. By ANYONE.\n";
		print "To build, you will need to add the following to CXXFLAGS:\n";
		print "\t-L/usr/local/lib -lgnugetopt -DHAVE_DECL_GETOPT=1\n";
 	}
	else
	{
		print "no ($version)\n";
	}
}
else
{
	print "no ($config{OSNAME})\n";
}

################################################################################
#			  BEGIN INTERACTIVE PART			      #
################################################################################

# clear screen
if ($interactive)
{
	print "\e[2J\e[0G\e[0d"; # J = Erase in Display, 2 = Entire Screen, (G, d) = Move cursor to (..,..)
	my $wholeos = $^O;

	my $rev = getrevision();
	# display introduction message
	print <<"STOP" ;
Welcome to the \e[1mInspIRCd\e[0m configuration program! (\e[1minteractive mode\e[0m)
\e[1mPackage maintainers: Type ./configure --help for non-interactive help\e[0m

*** If you are unsure of any of these values, leave it blank for    ***
*** standard settings that will work, and your server will run      ***
*** using them. Please consult your IRC network admin if in doubt.  ***

Press \e[1m<RETURN>\e[0m to accept the default for any option, or enter
a new value. Please note: You will \e[1mHAVE\e[0m to read the docs
directory, otherwise you won't have a configuration file!

Your operating system is: \e[1;32m$config{OSNAME}\e[0m ($wholeos)
Your InspIRCd revision ID is \e[1;32mr$rev\e[0m
STOP
	if ($rev eq "r0") {
		print " (Non-SVN build)";
	}
	print ".\n\n";

	$config{CHANGE_COMPILER} = "n";
	print "I have detected the following compiler: \e[1;32m$config{CC}\e[0m (version \e[1;32m$config{GCCVER}.$config{GCCMINOR}\e[0m)\n";

	while (($config{GCCVER} < 3) || ($config{GCCVER} eq "")) {
		print "\e[1;32mIMPORTANT!\e[0m A GCC 2.x compiler has been detected, and
should NOT be used. It is strongly encouraged you specify a newer compiler.\n\n";
		yesno('CHANGE_COMPILER',"Do you want to change the compiler?");
		if ($config{CHANGE_COMPILER} =~ /y/i) {
			print "What command do you wish to use to invoke your compiler?\n";
			print "[\e[1;32m$config{CC}\e[0m] -> ";
			chomp($config{CC} = <STDIN>);
			if ($config{CC} eq "") {
				$config{CC} = "g++";
			}
			chomp(my $foo = `$config{CC} -dumpversion | cut -c 1`);
			if ($foo ne "") {
				chomp($config{GCCVER}       = `$config{CC} -dumpversion | cut -c 1`); # we must redo these if we change compilers
				chomp($config{GCCMINOR}     = `$config{CC} -dumpversion | cut -c 3`);
				print "Queried compiler: \e[1;32m$config{CC}\e[0m (version \e[1;32m$config{GCCVER}.$config{GCCMINOR}\e[0m)\n";
				if ($config{GCCVER} < 3) {
					print "\e[1;32mGCC 2.x WILL NOT WORK!\e[0m. Let's try that again, shall we?\n";
				}
			}
			else {
				print "\e[1;32mWARNING!\e[0m Failure to execute the compiler you specified. You may want to try again.\n";
			}
		}
	}

	print "\n";

	# Directory settings
	my $tmpbase = $config{BASE_DIR};
	dir_check("do you wish to install the InspIRCd base", "BASE_DIR");
	if ($tmpbase ne $config{BASE_DIR}) {
		$config{CONFIG_DIR}	 = resolve_directory($config{BASE_DIR}."/conf");	# Configuration directory
		$config{MODULE_DIR}	 = resolve_directory($config{BASE_DIR}."/modules");	# Modules directory
		$config{DATA_DIR}	 = resolve_directory($config{BASE_DIR}."/data");	# Data directory
		$config{LOG_DIR}	 = resolve_directory($config{BASE_DIR}."/logs");	# Log directory
		$config{BINARY_DIR}	 = resolve_directory($config{BASE_DIR}."/bin");		# Binary directory
	}

	dir_check("are the configuration files", "CONFIG_DIR");
	dir_check("are the modules to be compiled to", "MODULE_DIR");
	dir_check("is the IRCd binary to be placed", "BINARY_DIR");
	dir_check("are variable data files to be located", "DATA_DIR");
	dir_check("are the logs to be stored", "LOG_DIR");
	dir_check("do you want the build to take place", "BUILD_DIR");
		
	my $chose_hiperf = 0;
	if ($has_kqueue) {
		yesno('USE_KQUEUE',"You are running a BSD operating system, and kqueue\nwas detected. Would you like to enable kqueue support?\nThis is likely to increase performance.\nIf you are unsure, choose yes.\n\nEnable kqueue?");
		print "\n";
		if ($config{USE_KQUEUE} eq "y") {
			$chose_hiperf = 1;
		}
	}
	if ($has_epoll) {
		yesno('USE_EPOLL',"You are running a Linux 2.6+ operating system, and epoll\nwas detected. Would you like to enable epoll support?\nThis is likely to increase performance.\nIf you are unsure, choose yes.\n\nEnable epoll?");
		print "\n";
		if ($config{USE_EPOLL} eq "y") {
			$chose_hiperf = 1;
		}
	}
	if ($has_ports) {
		yesno('USE_PORTS',"You are running Solaris 10.\nWould you like to enable I/O completion ports support?\nThis is likely to increase performance.\nIf you are unsure, choose yes.\n\nEnable support for I/O completion ports?");
		print "\n";
		if ($config{USE_PORTS} eq "y") {
			$chose_hiperf = 1;
		}
	}

	if (!$chose_hiperf) {
		yesno('USE_POLL', "Would you like to use poll?\n This is likely to increase performance.\nIf you are unsure, choose yes.\n\nEnable poll?");
		if ($config{USE_POLL} ne "y")
		{
			print "No high-performance socket engines are available, or you have chose\n";
			print "not to enable one. Defaulting to select() engine.\n\n";
		}
	}

	$config{USE_FREEBSD_BASE_SSL} = "n";
	$config{USE_FREEBSD_PORTS_SSL} = "n";
	if ($config{HAS_OPENSSL_PORT} ne "")
	{
		$config{USE_FREEBSD_PORTS_SSL} = "y";
		print "I have detected the OpenSSL FreeBSD port installed on your system,\n";
		print "version \e[1;32m".$config{HAS_OPENSSL_PORT}."\e[0m. Your base system OpenSSL is version \e[1;32m".$openssl_ver."\e[0m.\n\n";
		yesno('USE_FREEBSD_PORTS_SSL', "Do you want to use the FreeBSD ports version?");
		print "\n";
		$config{USE_FREEBSD_BASE_SSL} = "y" if ($config{USE_FREEBSD_PORTS_SSL} eq "n");

		if ($config{USE_FREEBSD_BASE_SSL} eq "n")
		{
			# update to port version
			$openssl_ver = $config{HAS_OPENSSL_PORT};
		}
	}
	else
	{
		$config{USE_FREEBSD_BASE_SSL} = "y" if ($^O eq "freebsd");
	}

	$config{USE_SSL} = "n";
	$config{MODUPDATE} = 'n';

	if ($config{HAS_GNUTLS} eq "y" || $config{HAS_OPENSSL} eq "y")
	{
		print "Detected GnuTLS version: \e[1;32m" . $gnutls_ver . "\e[0m\n";
		print "Detected OpenSSL version: \e[1;32m" . $openssl_ver . "\e[0m\n\n";

		yesno('USE_SSL', "One or more SSL libraries detected. Would you like to enable SSL support?");
		if ($config{USE_SSL} eq "y")
		{
			if ($config{HAS_GNUTLS} eq "y")
			{
				yesno('USE_GNUTLS',"Would you like to enable SSL through module m_ssl_gnutls? (recommended)");
				if ($config{USE_GNUTLS} eq "y")
				{
					print "\nUtilizing GnuTLS SSL module.\n";
				}
			}

			if ($config{HAS_OPENSSL} eq "y")
			{
				yesno('USE_OPENSSL', "Would you like to enable SSL through module m_ssl_openssl?");
				if ($config{USE_OPENSSL} eq "y")
				{
					print "\nUtilizing OpenSSL SSL module.\nYou will get better performance if you move to GnuTLS in the future.\n";
				}
			}
		}
	}
	else
	{
		print "\nNeither OpenSSL nor GnuTLS could be detected. Make sure pkg-config is installed and\n";
		print "is in your path.\n\n";
	}

	yesno('MODUPDATE',"Would you like to check for updates to third-party modules?");
	print "\n";
	if ($config{MODUPDATE} eq "y") {
		print "Checking for upgrades to extra- and third-party modules... ";
		system "./modulemanager upgrade";
	}
}

# we are on a POSIX system => we can enable POSIX extras without asking
symlink "extra/m_regex_posix.cpp", "src/modules/m_regex_posix.cpp";

dumphash();

if (($config{USE_GNUTLS} eq "y") && ($config{HAS_GNUTLS} ne "y"))
{
	print "Sorry, but I couldn't detect GnuTLS. Make sure gnutls-config is in your path.\n";
	exit(0);
}
if (($config{USE_OPENSSL} eq "y") && ($config{HAS_OPENSSL} ne "y"))
{
	print "Sorry, but I couldn't detect OpenSSL. Make sure openssl is in your path.\n";
	exit(0);
}
our $failed = 0;

$config{CERTGEN} ||= 'y';
yesno('CERTGEN',"Would you like to generate SSL certificates now?") if ($interactive && ($config{USE_GNUTLS} eq "y" || $config{USE_OPENSSL} eq "y"));

if ($config{USE_GNUTLS} eq "y") {
	unless (-r "src/modules/m_ssl_gnutls.cpp") {
		print "Symlinking src/modules/m_ssl_gnutls.cpp from extra/\n";
		symlink "extra/m_ssl_gnutls.cpp", "src/modules/m_ssl_gnutls.cpp" or print STDERR "Symlink failed: $!";
	}
	if ($interactive && $config{CERTGEN} eq 'y')
	{
		unless (-r "$config{CONFIG_DIR}/key.pem" && -r "$config{CONFIG_DIR}/cert.pem") {
			print "No current SSL certificates found, Generating.. \n\n
**************************************************************
* Generating the Private Key may take some time, go grab a   *
* coffee. Even better, to generate some more entropy if it   *
* is taking a while, open another console and type du / a    *
* few times and get that HD going :) Then, answer the        *
* questions which follow. If you are unsure, just hit enter! *
**************************************************************\n\n";
			$failed = make_gnutls_cert();
			if ($failed) {
				print "\n\e[1;32mCertificate generation failed!\e[0m\n\n";
			} else {
				print "\nCertificate generation complete, copying to config directory... ";
				File::Copy::move("key.pem", "$config{CONFIG_DIR}/key.pem") or print STDERR "Could not copy key.pem!\n";
				File::Copy::move("cert.pem", "$config{CONFIG_DIR}/cert.pem") or print STDERR "Could not copy cert.pem!\n";
				print "Done.\n\n";
			}
		}
		else {
			print "Current SSL certificates detected, therefore skipping.\n\n";
		}
	}
	else
	{
		print "Skipping SSL certificate generation\nin non-interactive mode.\n\n";
	}
}

if ($config{USE_OPENSSL} eq "y") {
	unless (-r "src/modules/m_ssl_openssl.cpp") {
		print "Symlinking src/modules/m_ssl_openssl.cpp from extra/\n";
		symlink "extra/m_ssl_openssl.cpp", "src/modules/m_ssl_openssl.cpp" or print STDERR "Symlink failed: $!";
	}
	$failed = 0;
	if ($interactive && $config{CERTGEN} eq 'y')
	{
		unless (-r "$config{CONFIG_DIR}/key.pem" && -r "$config{CONFIG_DIR}/cert.pem") {
			print "SSL Certificates Not found, Generating.. \n\n
*************************************************************
* Generating the certificates may take some time, go grab a *
* chair to throw at someone, or something.		    *
*************************************************************\n\n";
			make_openssl_cert();
			print "\nCertificate generation complete, copying to config directory... ";
			File::Copy::move("key.pem", "$config{CONFIG_DIR}/key.pem") or print STDERR "Could not copy key.pem!\n";
			File::Copy::move("cert.pem", "$config{CONFIG_DIR}/cert.pem") or print STDERR "Could not copy cert.pem!\n";
			File::Copy::move("dhparams.pem", "$config{CONFIG_DIR}/dhparams.pem") or print STDERR "Could not copy dhparams.pem!\n";
			print "Done.\n\n";
		} else {
			print "Current SSL certificates detected, therefore skipping.\n\n"
		}
	}
	else
	{
		print "Skipping SSL certificate generation\nin non-interactive mode.\n\n";
	}
}
if (($config{USE_GNUTLS} eq "n") && ($config{USE_OPENSSL} eq "n")) {
	print "Skipping SSL certificate generation as SSL support is not available.\n\n";
}

depcheck();
writefiles(1);
makecache();

print "\n\n";
print "To build your server with these settings, simply run '\e[1;32mmake\e[0m' now.\n";
if (($config{USE_GNUTLS} eq "y") || ($config{USE_OPENSSL} eq "y")) {
	print "Please note: for \e[1;32mSSL support\e[0m you will need to load required\n";
	print "modules in your config. This configure script has added those modules to the\n";
	print "build process. For more info, please refer to:\n";
	print "\e[1;32mhttp://wiki.inspircd.org/Installation_From_Tarball\e[0m\n";
}
print "*** \e[1;32mRemember to edit your configuration files!!!\e[0m ***\n\n\n";
if (($config{OSNAME} eq "OpenBSD") && ($config{CC} ne "eg++")) {
	print "\e[1;32mWARNING!\e[0m You are running OpenBSD but you are using the base GCC package\nrather than eg++. This compile will most likely fail, but we will proceed anyway - you\ngo ahead with it just so you can prove to yourself you are indeed mortal\n";
}

if ($config{GCCVER} < "3") {
	print <<FOO2;
\e[1;32mWARNING!\e[0m You are attempting to compile InspIRCd on GCC 2.x!
GCC 2.x series compilers only had partial (read as broken) C++ support, and
your compile will most likely fail catastrophically! If you have any problems, do NOT
report them to the bugtracker or forum without first upgrading your compiler
to a newer 3.x or 4.x (or whatever is available currently) version. Or just do that first.
FOO2
}

################################################################################
#			      HELPER FUNCTIONS				#
################################################################################
sub getcache {
	# retrieves .config.cache file, loads values into main configuration hash
	open(CACHE, ".config.cache") or return 0;
	while (<CACHE>) {
		chomp;
		# ignore blank lines & comments..
		next if /^\s*$/;
		next if /^\s*#/;
		my ($key, $value) = split("=", $_, 2);
		$value =~ /^\"(.*)\"$/;
		# Do something with data here!
		$config{$key} = $1;
	}
	close(CACHE);
	return 1;
}

sub makecache {
	# dump contents of %config
	print "Writing \e[1;32mcache file\e[0m for future ./configures ...\n";
	open(FILEHANDLE, ">.config.cache");
	foreach my $key (keys %config) {
		print FILEHANDLE "$key=\"$config{$key}\"\n";
	}
	close(FILEHANDLE);
}

sub dir_check {
	my ($desc, $hash_key) = @_;
	my $complete = 0;
	while (!$complete) {
		print "In what directory $desc?\n";
		print "[\e[1;32m$config{$hash_key}\e[0m] -> ";
		chomp(my $var = <STDIN>);
		if ($var eq "") {
			$var = $config{$hash_key};
		}
		if ($var =~ /^\~\/(.+)$/) {
			# convert it to a full path
			$var = resolve_directory($ENV{HOME} . "/" . $1);
		}
		elsif ((($config{OSNAME} =~ /MINGW32/i) and ($var !~ /^[A-Z]{1}:\\.*/)) and (substr($var,0,1) ne "/"))
		{
			# assume relative path was given, fill-in the rest
			$var = $this . "/$var";
		}

		$var = resolve_directory($var);
		if (! -e $var) {
			print "$var does not exist. Create it?\n[\e[1;32my\e[0m] ";
			chomp(my $tmp = <STDIN>);
			if (($tmp eq "") || ($tmp =~ /^y/i)) {
				# attempt to create directory
				my $chk = eval {
					use File::Path ();
					File::Path::mkpath($var, 0, 0777);
					1;
				};
				unless (defined($chk) && -d $var) {
					print "Unable to create directory. ($var)\n\n";
					# restart loop
					next;
				}
			} else {
				# Situation: They said they don't want to create, and we can't install there.
				print "\n\n";
				next;
			}
		} else {
			if (!is_dir($var)) {
				# Situation: Target exists, but is not a directory.
				print "File $var exists, but is not a directory.\n\n";
				next;
			}
		}
		# either directory exists, or was created without issue
		$config{$hash_key} = $var;
		$complete = 1;
		print "\n";
	}
}

our $SHARED = "";

my ($mliflags, $mfrules, $mobjs, $mfcount) = ("", "", "", 0);

sub writefiles {
	my($writeheader) = @_;
	# First file: inspircd_config.h
	chomp(my $incos = `uname -n -s -r`);
	chomp(my $version = `sh src/version.sh`);
	chomp(my $revision2 = getrevision());
	my $branch = "InspIRCd-0.0";
	if ($version =~ /^(InspIRCd-[0-9]+\.[0-9]+)\.[0-9]+/)
	{
		$branch = $1;
	}
	if ($writeheader == 1)
	{
		print "Writing \e[1;32minspircd_config.h\e[0m\n";
		open(FILEHANDLE, ">include/inspircd_config.h.tmp");
		print FILEHANDLE <<EOF;
/* Auto-generated by configure, do not modify! */
#ifndef __CONFIGURATION_AUTO__
#define __CONFIGURATION_AUTO__

/* Windows support hereafter. */
#define CoreExport /**/
#define DllExport /**/

#define CONFIG_PATH "$config{CONFIG_DIR}"
#define DATA_PATH "$config{DATA_DIR}"
#define LOG_PATH "$config{LOG_DIR}"
#define MOD_PATH "$config{MODULE_DIR}"
#define SOMAXCONN_S "$config{_SOMAXCONN}"
#define ENTRYPOINT int main(int argc, char** argv)

EOF
print FILEHANDLE "#define MAXBUF " . ($config{MAXBUF}+2) . "\n";

		if ($config{OSNAME} =~ /SunOS/i) {
			print FILEHANDLE "#define IS_SOLARIS\n";
		}
		if ($config{OSNAME} =~ /MINGW32/i) {
			print FILEHANDLE "#define IS_MINGW\n";
		}
		if ($config{GCCVER} >= 3) {
			print FILEHANDLE "#define GCC3\n";
		}
		if ($config{HAS_STRLCPY} eq "true") {
			print FILEHANDLE "#define HAS_STRLCPY\n";
		}
		if ($config{HAS_STDINT} eq "true") {
			print FILEHANDLE "#define HAS_STDINT\n";
		}
		if ($config{HAS_EVENTFD} eq 'true') {
			print FILEHANDLE "#define HAS_EVENTFD\n";
		}
		if ($config{OSNAME} !~ /DARWIN/i) {
			print FILEHANDLE "#define HAS_CLOCK_GETTIME\n";
		}
		my $use_hiperf = 0;
		if (($has_kqueue) && ($config{USE_KQUEUE} eq "y")) {
			print FILEHANDLE "#define USE_KQUEUE\n";
			$config{SOCKETENGINE} = "socketengine_kqueue";
			$use_hiperf = 1;
		}
		if (($has_epoll) && ($config{USE_EPOLL} eq "y")) {
			print FILEHANDLE "#define USE_EPOLL\n";
			$config{SOCKETENGINE} = "socketengine_epoll";
			$use_hiperf = 1;
		}
		if (($has_ports) && ($config{USE_PORTS} eq "y")) {
			print FILEHANDLE "#define USE_PORTS\n";
			$config{SOCKETENGINE} = "socketengine_ports";
			$use_hiperf = 1;
		}
		# user didn't choose either epoll or select for their OS
		#   => default them to USE_SELECT [ewwy puke puke]
		if (!$use_hiperf) {
			print "no hi-perf, " . $config{USE_POLL};
			if ($config{USE_POLL} eq "y")
			{
				print FILEHANDLE "#define USE_POLL\n";
				$config{SOCKETENGINE} = "socketengine_poll";
			}
			else
			{
				print FILEHANDLE "#define USE_SELECT\n";
				$config{SOCKETENGINE} = "socketengine_select";
			}
		}
		print FILEHANDLE "\n#include \"threadengines/threadengine_pthread.h\"\n\n#endif\n";
		close(FILEHANDLE);

		open(FILEHANDLE, ">include/inspircd_version.h.tmp");
		print FILEHANDLE <<EOF;
#define BRANCH "$branch"
#define VERSION "$version"
#define REVISION "$revision2"
#define SYSTEM "$incos"
EOF
		close FILEHANDLE;

		for my $file (qw(include/inspircd_config.h include/inspircd_version.h)) {
			my $diff = 0;
			open my $fh1, $file or $diff = 1;
			open my $fh2, $file.'.tmp' or die "Can't read $file.tmp that was just written: $!";
			while (!$diff) {
				my $line1 = <$fh1>;
				my $line2 = <$fh2>;
				if (defined($line1) != defined($line2)) {
					$diff = 1;
				} elsif (!defined $line1) {
					last;
				} else {
					$diff = ($line1 ne $line2);
				}
			}
			if ($diff) {
				unlink $file;
				rename "$file.tmp", $file;
			} else {
				unlink "$file.tmp";
			}
		}
	}

	# write all .in files
	my $tmp = "";
	my $file = "";
	my $exe = "inspircd";

	# Do this once here, and cache it in the .*.inc files,
	# rather than attempting to read src/version.sh from
	# compiled code -- we might not have the source to hand.
	# Fix for bug#177 by Brain.

	chomp($version = `sh ./src/version.sh`);
	chomp(my $revision = getrevision());
	$version = "$version(r$revision)";

	# We can actually parse any file starting with . and ending with .inc,
	# but right now we only parse .inspircd.inc to form './inspircd'
	prepare_dynamic_makefile();

	my @dotfiles = qw(main.mk inspircd);
	push @dotfiles, 'org.inspircd.plist' if $config{OSNAME} eq 'darwin';

	foreach my $file (@dotfiles) {
		open(FILEHANDLE, "make/template/$file") or die "Can't open make/template/$file: $!";
		$_ = join '', <FILEHANDLE>;
		close(FILEHANDLE);

		$config{BUILD_DIR} ||= resolve_directory($config{ME}."/build");

		for my $var (qw(
			CC SYSTEM BASE_DIR CONFIG_DIR MODULE_DIR BINARY_DIR BUILD_DIR DATA_DIR UID
			STARTSCRIPT DESTINATION SOCKETENGINE
		)) {
			s/\@$var\@/$config{$var}/g;
		}
		s/\@EXECUTABLE\@/$exe/ if defined $exe;
		s/\@VERSION\@/$version/ if defined $version;

		if ($file eq 'main.mk') {
			print "Writing \e[1;32mGNUmakefile\e[0m ...\n";

			my $mk_tmp = $_;
			s/\@IFDEF (\S+)/ifdef $1/g;
			s/\@IFNDEF (\S+)/ifndef $1/g;
			s/\@IFEQ (\S+) (\S+)/ifeq ($1,$2)/g;
			s/\@ELSIFEQ (\S+) (\S+)/else ifeq ($1,$2)/g;
			s/\@ELSE/else/g;
			s/\@ENDIF/endif/g;
			s/ *\@BSD_ONLY .*\n//g;
			s/\@GNU_ONLY //g;
			s/\@DO_EXPORT (.*)/export $1/g;
			open MKF, '>GNUmakefile' or die "Cannot write to GNUmakefile: $!";
			print MKF $_;
			close MKF;

			print "Writing \e[1;32mBSDmakefile\e[0m ...\n";
			$_ = $mk_tmp;
			s/\@IFDEF (\S+)/.if defined($1)/g;
			s/\@IFNDEF (\S+)/.if !defined($1)/g;
			s/\@IFEQ (\S+) (\S+)/.if $1 == $2/g;
			s/\@ELSIFEQ (\S+) (\S+)/.elif $1 == $2/g;
			s/\@ELSE/.else/g;
			s/\@ENDIF/.endif/g;
			s/\@BSD_ONLY //g;
			s/ *\@GNU_ONLY .*\n//g;
			$mk_tmp = $_;
			$mk_tmp =~ s#\@DO_EXPORT (.*)#"MAKEENV += ".join ' ', map "$_='\${$_}'", split /\s/, $1#eg;
			open MKF, '>BSDmakefile' or die "Cannot write to BSDmakefile: $!";
			print MKF $mk_tmp;
			close MKF;
		} else {
			print "Writing \e[1;32m$file\e[0m ...\n";
			open(FILEHANDLE, ">$file") or die("Cannot write to $file: $!\n");
			print FILEHANDLE $_;
			close(FILEHANDLE);
		}
	}

	chmod 0755, 'inspircd';
}

sub depcheck
{
	getmodules();
	for my $mod (@modlist) {
		getcompilerflags("src/modules/m_$mod.cpp");
		getlinkerflags("src/modules/m_$mod.cpp");
	}
}

sub prepare_dynamic_makefile
{
	my $i = 0;

	if (!$has_epoll)
	{
		$config{USE_EPOLL} = 0;
	}
	if (!$has_kqueue)
	{
		$config{USE_KQUEUE} = 0;
	}
	if (!$has_ports)
	{
		$config{USE_PORTS} = 0;
	}
}

# Routine is to list the extra/ modules that have been enabled
# Note: when getting any filenames out & comparing, it's important to lc it if the
#  filesystem is not case-sensitive (== Epoc, MacOS, OS/2 (incl. DOS/DJGPP), VMS, Win32
#  (incl NetWare, Symbian)). Cygwin may or may not be case-sensitive, depending on
#  configuration, however, File::Spec does not currently tell us (it assumes Unix behavior).
sub list_extras () {
	use File::Spec;
	# @_ not used
	my $srcdir = File::Spec->catdir("src", "modules");
	my $abs_srcdir = File::Spec->rel2abs($srcdir);
	local $_;
	my $dd;
	opendir $dd, File::Spec->catdir($abs_srcdir, "extra") or die (File::Spec->catdir($abs_srcdir, "extra") . ": $!\n");
	my @extras = map { File::Spec->case_tolerant() ? lc($_) : $_ } (readdir($dd));
	closedir $dd;
	undef $dd;
	opendir $dd, $abs_srcdir or die "$abs_srcdir: $!\n";
	my @sources = map { File::Spec->case_tolerant() ? lc($_) : $_ } (readdir($dd));
	closedir $dd;
	undef $dd;
	my $maxlen = (sort { $b <=> $a } (map {length($_)} (@extras)))[0];
	my %extras = ();
EXTRA:	for my $extra (@extras) {
		next if (File::Spec->curdir() eq $extra || File::Spec->updir() eq $extra);
		my $abs_extra = File::Spec->catfile($abs_srcdir, "extra", $extra);
		my $abs_source = File::Spec->catfile($abs_srcdir, $extra);
		next unless ($extra =~ m/\.(cpp|h)$/ || (-d $abs_extra)); # C++ Source/Header, or directory
		if (-l $abs_source) {
			# Is the symlink in the correct place?
			my $targ = readlink($abs_source);
			my $abs_targ = File::Spec->rel2abs($targ, $abs_srcdir);
			if ($abs_targ eq $abs_extra) {
				$extras{$extra} = "\e[32;1menabled\e[0m";
			} else {
				$extras{$extra} = sprintf("\e[31;1mwrong symlink target (%s)\e[0m", $abs_targ);
			}
		} elsif (-e $abs_source) {
			my ($devext, $inoext) = stat($abs_extra);
			my ($devsrc, $inosrc, undef, $lnksrc) = stat($abs_source);
			if ($lnksrc > 1) {
				if ($devsrc == $devext && $inosrc == $inoext) {
					$extras{$extra} = "\e[32;1menabled\e[0m";
				} else {
					$extras{$extra} = sprintf("\e[31;1mwrong hardlink target (%d:%d)\e[0m", $devsrc, $inosrc);
				}
			} else {
				open my $extfd, "<", $abs_extra;
				open my $srcfd, "<", $abs_source;
				local $/ = undef;
				if (scalar(<$extfd>) eq scalar(<$srcfd>)) {
					$extras{$extra} = "\e[32;1menabled\e[0m";
				} else {
					$extras{$extra} = sprintf("\e[31;1mout of sync (re-copy)\e[0m");
				}
			}
		} else {
			$extras{$extra} = "\e[33;1mdisabled\e[0m";
		}
	}
	# add dependency info
	for my $extra (keys(%extras)) {
		next unless $extras{$extra} =~ m/enabled/; # only process enabled extras
		my $abs_extra = File::Spec->catfile($abs_srcdir, "extra", $extra);
		my @deps = split / +/, getdependencies($abs_extra);
		for my $dep (@deps) {
			if (exists($extras{$dep})) {
				my $ref = \$extras{$dep}; # take reference
				if ($$ref !~ m/needed by/) {
					# 1st dependency found
					if ($$ref =~ m/enabled/) {
						$$ref .= " (needed by \e[32;1m$extra\e[0m";
					} else {
						$$ref =~ s/\e\[.*?m//g; # strip all former colorization -- set in bold+red+blink later
						$$ref .= " (needed by \e[0;32;1;5m$extra\e[0;31;1;5m";
					}
				} else {
					if ($$ref =~ m/enabled/) {
						$$ref .= ", \e[32;1m$extra\e[0m";
					} else {
						$$ref .= ", \e[0;32;1;5m$extra\e[0;31;1;5m";
					}
				}
			}
		}
	}
	for my $extra (sort {$a cmp $b} keys(%extras)) {
		my $text = $extras{$extra};
		if ($text =~ m/needed by/ && $text !~ m/enabled/) {
			printf "\e[31;1;5m%-*s = %s%s\e[0m\n", $maxlen, $extra, $text, ($text =~ m/needed by/ ? ")" : "");
		} else {
			printf "%-*s = %s%s\n", $maxlen, $extra, $text, ($text =~ m/needed by/ ? "\e[0m)" : "");
		}
	}
	return keys(%extras) if wantarray; # can be used by manage_extras
}

sub enable_extras (@) {
	my (@extras) = @_;
	for my $extra (@extras) {
		my $extrapath = "src/modules/extra/$extra";
		if (!-e $extrapath) {
			print STDERR "Cannot enable \e[32;1m$extra\e[0m : No such file or directory in src/modules/extra\n";
			next;
		}
		my $source = "src/modules/$extra";
		if (-e $source) {
			print STDERR "Cannot enable \e[32;1m$extra\e[0m : destination in src/modules exists (may already be enabled?)\n";
			next;
		}
		# obtain dependencies & add them to processing queue
		my @deps = split / +/, getdependencies($extrapath);
		for my $dep (@deps) {
			next if scalar(grep { $_ eq $dep } (@extras)) > 0; # omit this step if they are to be enabled
			if (!-e "src/modules/$dep") {
				if (-e "src/modules/extra/$dep") {
					print STDERR "Will also enable extra \e[32;1m$dep\e[0m (needed by \e[32;1m$extra\e[0m)\n";
					push @extras, $dep;
				} else {
					print STDERR "\e[33;1mWARNING:\e[0m module \e[32;1m$extra\e[0m might be missing dependency \e[32;1m$dep\e[0m - YOU are responsible for satisfying it!\n";
				}
			}
		}
		print "Enabling $extra ... \n";
		symlink "extra/$extra", $source or print STDERR "$source: Cannot link to 'extra/$extra': $!\n";
	}
}

sub disable_extras (@)
{
	opendir my $dd, "src/modules/extra/";
	my @files = readdir($dd);
	closedir $dd;
	my (@extras) = @_;
EXTRA:	for my $extra (@extras) {
		my $extrapath = "src/modules/extra/$extra";
		my $source = "src/modules/$extra";
		if (!-e $extrapath) {
			print STDERR "Cannot disable \e[32;1m$extra\e[0m : Is not an extra\n";
			next;
		}
		if ((! -l $source) || readlink($source) ne "extra/$extra") {
			print STDERR "Cannot disable \e[32;1m$extra\e[0m : Source is not a link or doesn't refer to the correct file. Remove manually if this is in error.\n";
			next;
		}
		# check if anything requires this...
		for my $file (@files) {
			my @deps = split / +/, getdependencies("src/modules/extra/$file");
			# file depends on this extra...
			if (scalar(grep { $_ eq $extra } @deps) > 0) {
				# ...and is both enabled, and not about to be disabled.
				if (-e "src/modules/$file" && scalar(grep { $_ eq $file } @extras) < 1) {
					print STDERR "Cannot disable \e[32;1m$extra\e[0m : is needed by \e[32;1m$file\e[0m\n";
					next EXTRA;
				}
			}
		}
		# now safe to remove
		print "Disabling $extra ... \n";
		unlink "src/modules/$extra" or print STDERR "Cannot disable \e[32;1m$extra\e[0m : $!\n";
	}
}

/*
 * InspIRCd -- Internet Relay Chat Daemon
 *
 *   Copyright (C) 2009 Daniel De Graaf <danieldg@inspircd.org>
 *   Copyright (C) 2007 Craig Edwards <craigedwards@brainbox.cc>
 *   Copyright (C) 2012 Adam <Adam@anope.org>
 *
 * This file is part of InspIRCd.  InspIRCd is free software: you can
 * redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, version 2.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


#pragma once

#if defined HAS_CXX11_VARIADIC_TEMPLATES

template<typename ReturnType, typename... Args> class CoreExport Handler : public classbase
{
 public:
	virtual ~Handler() { }
	virtual ReturnType Call(Args...) = 0;
};

template<typename ReturnType, typename... Args> class CoreExport Caller
{
 public:
	Handler<ReturnType, Args...>* target;

	Caller(Handler<ReturnType, Args...>* initial) : target(initial) { }
	virtual ~Caller() { }

	virtual ReturnType operator()(const Args&... params)
	{
		return this->target->Call(params...);
	}
};

/* Below here is compat with the old API */
#define HandlerBase0 Handler
#define HandlerBase1 Handler
#define HandlerBase2 Handler
#define HandlerBase3 Handler
#define HandlerBase4 Handler
#define HandlerBase5 Handler
#define HandlerBase6 Handler
#define HandlerBase7 Handler
#define HandlerBase8 Handler

#define caller1 Caller
#define caller2 Caller
#define caller3 Caller
#define caller4 Caller
#define caller5 Caller
#define caller6 Caller
#define caller7 Caller
#define caller8 Caller

#define DEFINE_HANDLER0(NAME, RETURN) \
	class CoreExport NAME : public Handler<RETURN> { public: NAME() { } virtual RETURN Call(); }

#define DEFINE_HANDLER1(NAME, RETURN, V1) \
	class CoreExport NAME : public Handler<RETURN, V1> { public: NAME() { } virtual RETURN Call(V1); }

#define DEFINE_HANDLER2(NAME, RETURN, V1, V2) \
	class CoreExport NAME : public Handler<RETURN, V1, V2> { public: NAME() { } virtual RETURN Call(V1, V2); }

#define DEFINE_HANDLER3(NAME, RETURN, V1, V2, V3) \
	class CoreExport NAME : public Handler<RETURN, V1, V2, V3> { public: NAME() { } virtual RETURN Call(V1, V2, V3); }

#define DEFINE_HANDLER4(NAME, RETURN, V1, V2, V3, V4) \
	class CoreExport NAME : public Handler<RETURN, V1, V2, V3, V4> { public: NAME() { } virtual RETURN Call(V1, V2, V3, V4); }

#define DEFINE_HANDLER5(NAME, RETURN, V1, V2, V3, V4, V5) \
	class CoreExport NAME : public Handler<RETURN, V1, V2, V3, V4, V5> { public: NAME() { } virtual RETURN Call(V1, V2, V3, V4, V5); }

#define DEFINE_HANDLER6(NAME, RETURN, V1, V2, V3, V4, V5, V6) \
	class CoreExport NAME : public Handler<RETURN, V1, V2, V3, V4, V5, V6> { public: NAME() { } virtual RETURN Call(V1, V2, V3, V4, V5, V6); }

#define DEFINE_HANDLER7(NAME, RETURN, V1, V2, V3, V4, V5, V6, V7) \
	class CoreExport NAME : public Handler<RETURN, V1, V2, V3, V4, V5, V6, V7> { public: NAME() { } virtual RETURN Call(V1, V2, V3, V4, V5, V6, V7); }

#define DEFINE_HANDLER8(NAME, RETURN, V1, V2, V3, V4, V5, V6, V7, V8) \
	class CoreExport NAME : public Handler<RETURN, V1, V2, V3, V4, V5, V6, V7, V8> { public: NAME() { } virtual RETURN Call(V1, V2, V3, V4, V5, V6, V7, V8); }

#else

/** The templates below can be auto generated by tools/create_templates.pl.
 * They are used to represent a functor with a given number of parameters and
 * a specific return type. To prevent passing the wrong number of parameters
 * and have the compiler detect this error at build-time, each class is numbered
 * according to the number of parameters it takes, e.g. caller0, caller1, caller2.
 * These have been generated from zero parameters to eight.
 *
 * If you want to declare a functor which takes two parameters, a User and a Channel,
 * and returns bool, simply create it like this:
 *
 * caller2<bool, User*, Channel*> MyFunction;
 *
 * and initialize it correctly, when placed into a class you will be able to call it:
 *
 * bool n = someclass->MyFunction(someuser, somechan);
 *
 * These functor templates work this way so that you can simply and easily allow
 * for these class methods to be overridden from within a module, e.g. have a module
 * which completely replaces the code for IsNick, etc. For example, with the example
 * above:
 *
 * MyNewFunction replaceme(ServerInstance);
 *
 * someclass->MyFunction = \&replaceme;
 *
 * After this point, calls to someclass->MyFunction will call the new code in your
 * replacement functor.
 *
 * This is a very powerful feature which should be considered 'advanced' and not for
 * beginners. If you do not understand these templates, STAY AWAY from playing with
 * this until you do, as if you get this wrong, this can generate some pretty long
 * winded and confusing error messages at compile time.
 */
template <typename ReturnType> class CoreExport HandlerBase0 : public classbase
{
 public:
	virtual ReturnType Call() = 0;
	virtual ~HandlerBase0() { }
};

template <typename ReturnType, typename Param1> class CoreExport HandlerBase1 : public classbase
{
 public:
	virtual ReturnType Call(Param1) = 0;
	virtual ~HandlerBase1() { }
};

template <typename ReturnType, typename Param1, typename Param2> class CoreExport HandlerBase2 : public classbase
{
 public:
	virtual ReturnType Call(Param1, Param2) = 0;
	virtual ~HandlerBase2() { }
};

template <typename ReturnType, typename Param1, typename Param2, typename Param3> class CoreExport HandlerBase3 : public classbase
{
 public:
	virtual ReturnType Call(Param1, Param2, Param3) = 0;
	virtual ~HandlerBase3() { }
};

template <typename ReturnType, typename Param1, typename Param2, typename Param3, typename Param4> class CoreExport HandlerBase4 : public classbase
{
 public:
	virtual ReturnType Call(Param1, Param2, Param3, Param4) = 0;
	virtual ~HandlerBase4() { }
};

template <typename ReturnType, typename Param1, typename Param2, typename Param3, typename Param4, typename Param5> class CoreExport HandlerBase5 : public classbase
{
 public:
	virtual ReturnType Call(Param1, Param2, Param3, Param4, Param5) = 0;
	virtual ~HandlerBase5() { }
};

template <typename ReturnType, typename Param1, typename Param2, typename Param3, typename Param4, typename Param5, typename Param6> class CoreExport HandlerBase6 : public classbase
{
 public:
	virtual ReturnType Call(Param1, Param2, Param3, Param4, Param5, Param6) = 0;
	virtual ~HandlerBase6() { }
};

template <typename ReturnType, typename Param1, typename Param2, typename Param3, typename Param4, typename Param5, typename Param6, typename Param7> class CoreExport HandlerBase7 : public classbase
{
 public:
	virtual ReturnType Call(Param1, Param2, Param3, Param4, Param5, Param6, Param7) = 0;
	virtual ~HandlerBase7() { }
};

template <typename ReturnType, typename Param1, typename Param2, typename Param3, typename Param4, typename Param5, typename Param6, typename Param7, typename Param8> class CoreExport HandlerBase8 : public classbase
{
 public:
	virtual ReturnType Call(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8) = 0;
	virtual ~HandlerBase8() { }
};

template <typename HandlerType> class caller
{
 public:
	HandlerType* target;

	caller(HandlerType* initial)
	: target(initial)
	{ }

	virtual ~caller() { }
};

template <typename ReturnType> class caller0 : public caller< HandlerBase0<ReturnType> >
{
 public:
	caller0(HandlerBase0<ReturnType>* initial)
	: caller< HandlerBase0<ReturnType> >::caller(initial)
	{ }

	ReturnType operator() ()
	{
		return this->target->Call();
	}
};

template <typename ReturnType, typename Param1> class caller1 : public caller< HandlerBase1<ReturnType, Param1> >
{
 public:
	caller1(HandlerBase1<ReturnType, Param1>* initial)
	: caller< HandlerBase1<ReturnType, Param1> >(initial)
	{ }

	ReturnType operator() (Param1 param1)
	{
		return this->target->Call(param1);
	}
};

template <typename ReturnType, typename Param1, typename Param2> class caller2 : public caller< HandlerBase2<ReturnType, Param1, Param2> >
{
 public:
	caller2(HandlerBase2<ReturnType, Param1, Param2>* initial)
	: caller< HandlerBase2<ReturnType, Param1, Param2> >(initial)
	{ }

	ReturnType operator() (Param1 param1, Param2 param2)
	{
		return this->target->Call(param1, param2);
	}
};

template <typename ReturnType, typename Param1, typename Param2, typename Param3> class caller3 : public caller< HandlerBase3<ReturnType, Param1, Param2, Param3> >
{
 public:
	caller3(HandlerBase3<ReturnType, Param1, Param2, Param3>* initial)
	: caller< HandlerBase3<ReturnType, Param1, Param2, Param3> >(initial)
	{ }

	ReturnType operator() (Param1 param1, Param2 param2, Param3 param3)
	{
		return this->target->Call(param1, param2, param3);
	}
};

template <typename ReturnType, typename Param1, typename Param2, typename Param3, typename Param4> class caller4 : public caller< HandlerBase4<ReturnType, Param1, Param2, Param3, Param4> >
{
 public:
	caller4(HandlerBase4<ReturnType, Param1, Param2, Param3, Param4>* initial)
	: caller< HandlerBase4<ReturnType, Param1, Param2, Param3, Param4> >(initial)
	{ }

	ReturnType operator() (Param1 param1, Param2 param2, Param3 param3, Param4 param4)
	{
		return this->target->Call(param1, param2, param3, param4);
	}
};

template <typename ReturnType, typename Param1, typename Param2, typename Param3, typename Param4, typename Param5> class caller5 : public caller< HandlerBase5<ReturnType, Param1, Param2, Param3, Param4, Param5> >
{
 public:
	caller5(HandlerBase5<ReturnType, Param1, Param2, Param3, Param4, Param5>* initial)
	: caller< HandlerBase5<ReturnType, Param1, Param2, Param3, Param4, Param5> >(initial)
	{ }

	ReturnType operator() (Param1 param1, Param2 param2, Param3 param3, Param4 param4, Param5 param5)
	{
		return this->target->Call(param1, param2, param3, param4, param5);
	}
};

template <typename ReturnType, typename Param1, typename Param2, typename Param3, typename Param4, typename Param5, typename Param6> class caller6 : public caller< HandlerBase6<ReturnType, Param1, Param2, Param3, Param4, Param5, Param6> >
{
 public:
	caller6(HandlerBase6<ReturnType, Param1, Param2, Param3, Param4, Param5, Param6>* initial)
	: caller< HandlerBase6<ReturnType, Param1, Param2, Param3, Param4, Param5, Param6> >(initial)
	{ }

	ReturnType operator() (Param1 param1, Param2 param2, Param3 param3, Param4 param4, Param5 param5, Param6 param6)
	{
		return this->target->Call(param1, param2, param3, param4, param5, param6);
	}
};

template <typename ReturnType, typename Param1, typename Param2, typename Param3, typename Param4, typename Param5, typename Param6, typename Param7> class caller7 : public caller< HandlerBase7<ReturnType, Param1, Param2, Param3, Param4, Param5, Param6, Param7> >
{
 public:
	caller7(HandlerBase7<ReturnType, Param1, Param2, Param3, Param4, Param5, Param6, Param7>* initial)
	: caller< HandlerBase7<ReturnType, Param1, Param2, Param3, Param4, Param5, Param6, Param7> >(initial)
	{ }

	ReturnType operator() (Param1 param1, Param2 param2, Param3 param3, Param4 param4, Param5 param5, Param6 param6, Param7 param7)
	{
		return this->target->Call(param1, param2, param3, param4, param5, param6, param7);
	}
};

template <typename ReturnType, typename Param1, typename Param2, typename Param3, typename Param4, typename Param5, typename Param6, typename Param7, typename Param8> class caller8 : public caller< HandlerBase8<ReturnType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8> >
{
 public:
	caller8(HandlerBase8<ReturnType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8>* initial)
	: caller< HandlerBase8<ReturnType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8> >(initial)
	{ }

	ReturnType operator() (Param1 param1, Param2 param2, Param3 param3, Param4 param4, Param5 param5, Param6 param6, Param7 param7, Param8 param8)
	{
		return this->target->Call(param1, param2, param3, param4, param5, param6, param7, param8);
	}
};

/** These shorthand macros are used to define a functor class which only implements Call(). Most functors are like this.
 * If you want something more complex, define them by hand.
 *
 * The first parameter to each macro is the class name to define, the second parameter is the return value of Call().
 * The following parameters are the parameter types for Call(), and again, the macro is numbered to match the number of
 * parameters, to prevent mistakes.
 */
#define DEFINE_HANDLER0(NAME, RETURN) \
	class CoreExport NAME : public HandlerBase0<RETURN> { public: NAME() { } virtual ~NAME() { } virtual RETURN Call(); }

#define DEFINE_HANDLER1(NAME, RETURN, V1) \
	class CoreExport NAME : public HandlerBase1<RETURN, V1> { public: NAME() { } virtual ~NAME() { } virtual RETURN Call(V1); }

#define DEFINE_HANDLER2(NAME, RETURN, V1, V2) \
	class CoreExport NAME : public HandlerBase2<RETURN, V1, V2> { public: NAME() { } virtual ~NAME() { } virtual RETURN Call(V1, V2); }

#define DEFINE_HANDLER3(NAME, RETURN, V1, V2, V3) \
	class CoreExport NAME : public HandlerBase3<RETURN, V1, V2, V3> { public: NAME() { } virtual ~NAME() { } virtual RETURN Call(V1, V2, V3); }

#define DEFINE_HANDLER4(NAME, RETURN, V1, V2, V3, V4) \
	class CoreExport NAME : public HandlerBase4<RETURN, V1, V2, V3, V4> { public: NAME() { } virtual ~NAME() { } virtual RETURN Call(V1, V2, V3, V4); }

#define DEFINE_HANDLER5(NAME, RETURN, V1, V2, V3, V4, V5) \
	class CoreExport NAME : public HandlerBase5<RETURN, V1, V2, V3, V4, V5> { public: NAME() { } virtual ~NAME() { } virtual RETURN Call(V1, V2, V3, V4, V5); }

#define DEFINE_HANDLER6(NAME, RETURN, V1, V2, V3, V4, V5, V6) \
	class CoreExport NAME : public HandlerBase6<RETURN, V1, V2, V3, V4, V5, V6> { public: NAME() { } virtual ~NAME() { } virtual RETURN Call(V1, V2, V3, V4, V5, V6); }

#define DEFINE_HANDLER7(NAME, RETURN, V1, V2, V3, V4, V5, V6, V7) \
	class CoreExport NAME : public HandlerBase7<RETURN, V1, V2, V3, V4, V5, V6, V7> { public: NAME() { } virtual ~NAME() { } virtual RETURN Call(V1, V2, V3, V4, V5, V6, V7); }

#define DEFINE_HANDLER8(NAME, RETURN, V1, V2, V3, V4, V5, V6, V7, V8) \
	class CoreExport NAME : public HandlerBase8<RETURN, V1, V2, V3, V4, V5, V6, V7, V8> { public: NAME() { } virtual ~NAME() { } virtual RETURN Call(V1, V2, V3, V4, V5, V6, V7, V8); }

#endif
